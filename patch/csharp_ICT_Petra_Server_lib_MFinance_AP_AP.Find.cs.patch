--- trunk/csharp/ICT/Petra/Server/lib/MFinance/AP/AP.Find.cs	2014-05-10 06:50:27.000000000 +0200
+++ remoting/csharp/ICT/Petra/Server/lib/MFinance/AP/AP.Find.cs	2014-05-10 06:53:13.000000000 +0200
@@ -70,25 +70,20 @@
     ///          However, Server Objects that derive from these objects and that
     ///          are also UIConnectors are feasible.
     ///</summary>
-    public class TFindUIConnector : TConfigurableMBRObject, IAPUIConnectorsFind
+    public class TFindUIConnector : IAPUIConnectorsFind
     {
         /// <summary>Paged query object</summary>
         TPagedDataSet FPagedDataSetObject;
 
-        /// <summary>Asynchronous execution control object</summary>
-        TAsynchronousExecutionProgress FAsyncExecProgress;
-
         /// <summary>Thread that is used for asynchronously executing the Find query</summary>
         Thread FFindThread;
 
-        /// <summary>Returns reference to the Asynchronous execution control object to the caller</summary>
-        public IAsynchronousExecutionProgress AsyncExecProgress
+        /// <summary>Get the current state of progress</summary>
+        public TProgressState Progress
         {
             get
             {
-                return (IAsynchronousExecutionProgress)TCreateRemotableObject.CreateRemotableObject(
-                    typeof(TAsynchronousExecutionProgressRemote),
-                    FAsyncExecProgress);
+                return FPagedDataSetObject.Progress;
             }
         }
 
@@ -173,17 +168,8 @@
         /// <param name="ACriteriaData">HashTable containing non-empty Find parameters</param>
         public void PerformSearch(DataTable ACriteriaData)
         {
-            FAsyncExecProgress = new TAsynchronousExecutionProgress();
-
             FPagedDataSetObject = new TPagedDataSet(null);
 
-            // Pass the TAsynchronousExecutionProgress object to FPagedDataSetObject
-            // so that it can update execution status
-            FPagedDataSetObject.AsyncExecProgress = FAsyncExecProgress;
-
-            // Register Event Handler for the StopAsyncronousExecution event
-            FAsyncExecProgress.StopAsyncronousExecution += new System.EventHandler(this.StopSearch);
-
             DataRow CriteriaRow = PrepareDataRow(ACriteriaData);
             Int32 ledgerNumber = (Int32)CriteriaRow["LedgerNumber"];
 
@@ -291,6 +277,7 @@
             try
             {
                 FFindThread = new Thread(new ThreadStart(FPagedDataSetObject.ExecuteQuery));
+                FFindThread.Name = "APFind" + Guid.NewGuid().ToString();
                 FFindThread.Start();
             }
             catch (Exception)
@@ -302,8 +289,6 @@
         /// <summary>
         /// Stops the query execution.
         ///
-        /// Is intended to be called as an Event from FAsyncExecProgress.Cancel.
-        ///
         /// @comment It might take some time until the executing query is cancelled by
         /// the DB, but this procedure returns immediately. The reason for this is that
         /// we consider the query cancellation as done since the application can
@@ -312,11 +297,7 @@
         /// errors that state that a ADO.NET command is still executing!).
         ///
         /// </summary>
-        /// <param name="ASender">Object that requested the stopping (not evaluated)</param>
-        /// <param name="AArgs">(not evaluated)
-        /// </param>
-        /// <returns>void</returns>
-        public void StopSearch(object ASender, EventArgs AArgs)
+        public void StopSearch()
         {
             Thread StopQueryThread;
 
@@ -325,6 +306,7 @@
             ThreadStart ThreadStartDelegate = new ThreadStart(FPagedDataSetObject.StopQuery);
 
             StopQueryThread = new Thread(ThreadStartDelegate);
+            StopQueryThread.Name = "APFindStopQuery" + Guid.NewGuid().ToString();
             StopQueryThread.Start();
 
             /* It might take some time until the executing query is cancelled by the DB,
