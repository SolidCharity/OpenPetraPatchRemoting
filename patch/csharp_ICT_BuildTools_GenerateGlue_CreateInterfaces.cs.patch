--- trunk/csharp/ICT/BuildTools/GenerateGlue/CreateInterfaces.cs	2014-05-10 06:50:27.000000000 +0200
+++ remoting/csharp/ICT/BuildTools/GenerateGlue/CreateInterfaces.cs	2014-05-10 06:53:13.000000000 +0200
@@ -4,7 +4,7 @@
 // @Authors:
 //       timop
 //
-// Copyright 2004-2012 by OM International
+// Copyright 2004-2013 by OM International
 //
 // This file is part of OpenPetra.org.
 //
@@ -139,12 +139,6 @@
                     continue;
                 }
 
-                if (!p.GetRegion.Block.ToString().Contains("TCreateRemotableObject"))
-                {
-                    TLogging.Log("Warning: properties in UIConnectors must use the class TCreateRemotableObject: " +
-                        AServerNamespace + "." + t.Name + "." + p.Name);
-                }
-
                 // don't write namespace hierarchy here
                 if (p.TypeReference.Type.IndexOf("Namespace") == -1)
                 {
@@ -224,162 +218,6 @@
         return true;
     }
 
-    /// <summary>
-    /// write the interfaces for the Connectors
-    /// parses the connector files
-    /// </summary>
-    /// <param name="ATemplate">template that the code should be added to</param>
-    /// <param name="AMethodsAlreadyWritten">a string list of method names that have been written</param>
-    /// <param name="AConnectorClasses">all connector classes that implement the interface</param>
-    /// <param name="AInterfaceName">the name of the interface we are writing to; it ends with ConnectorsNamespace</param>
-    /// <param name="AInterfaceNamespace"></param>
-    /// <param name="AServerNamespace">for the comment in the autogenerated code</param>
-    /// <returns></returns>
-    private bool WriteConnectorConstructors(
-        ProcessTemplate ATemplate,
-        ref StringCollection AMethodsAlreadyWritten,
-        List <TypeDeclaration>AConnectorClasses, String AInterfaceName, String AInterfaceNamespace, String AServerNamespace)
-    {
-        string ServerNamespace = AInterfaceNamespace.Replace("Ict.Petra.Shared.Interfaces", "Ict.Petra.Server");
-
-        foreach (TypeDeclaration t in AConnectorClasses)
-        {
-            string ConnectorClassName = t.Name;
-
-            // cacheable will not work yet; careful: when building MethodName, connectorName does not have a plural s
-            // but that cacheable constructor is not needed anyways???
-
-            if (ConnectorClassName.StartsWith("T")
-                && (ConnectorClassName.EndsWith("UIConnector")
-                    || ConnectorClassName.EndsWith("LogicConnector")
-                    || ConnectorClassName.EndsWith("Lookup")
-                    || ConnectorClassName.EndsWith("Reader")))
-            {
-                // create a method for the interface, that returns the interface that the connector class is derived from,
-                // and takes the parameters from the constructor of the connector class
-                // it is named: remove first character T and trailing UIConnector/LogicConnector from the name of the connector class
-
-                // get the connector name from the namespace
-                StringCollection namespaceList = StringHelper.StrSplit(ServerNamespace, ".");
-
-                // connectorName eg. UIConnectors, LogicConnectors, ServerLookups, Cacheable
-                string connectorName = namespaceList[namespaceList.Count - 1];
-                string MethodName = ConnectorClassName.Substring(1,
-                    ConnectorClassName.Length - 1 - (connectorName.Length - 1));
-                string MethodType = "";
-
-                foreach (TypeReference ti in t.BaseTypes)
-                {
-                    // problem, eg. in MCommon, TOfficeSpecificDataLabelsUIConnector implements 2 interfaces
-                    if ((ti.Type != "TConfigurableMBRObject")
-                        && (ti.Type == AInterfaceName))
-                    {
-                        MethodType = ti.Type;
-                    }
-                }
-
-                if (MethodType.Length == 0)
-                {
-                    // no valid interface has been derived; eg. Hospitality not finished yet
-                    continue;
-                }
-
-                List <ConstructorDeclaration>constructors = CSParser.GetConstructors(t);
-
-                if (constructors.Count == 0)
-                {
-                    // will cause compile error if the constructor is missing, because it is not implementing the interface completely
-                    throw new Exception("missing a connector constructor in " + ServerNamespace + "." + ConnectorClassName);
-
-//                    WriteLine("/// <summary>auto generated - there was no Connector constructor (" + ServerNamespace + "." + ConnectorClassName + ")</summary>");
-//                    AMethodsAlreadyWritten.Add(MethodName);
-//                    string MethodDeclaration = MethodType + " " + MethodName + "();";
-//                    WriteLine(MethodDeclaration);
-                }
-                else
-                {
-                    // find constructor and copy the parameters
-                    foreach (ConstructorDeclaration m in constructors)
-                    {
-                        ATemplate.AddToCodelet(
-                            "CONTENT",
-                            "/// <summary>auto generated from Connector constructor (" + ServerNamespace + "." + ConnectorClassName + ")</summary>" +
-                            Environment.NewLine);
-                        AMethodsAlreadyWritten.Add(MethodName);
-                        string MethodDeclaration = MethodType + " " + MethodName + "(";
-                        int align = MethodDeclaration.Length;
-                        bool firstParameter = true;
-
-                        foreach (ParameterDeclarationExpression p in m.Parameters)
-                        {
-                            AutoGenerationTools.AddParameter(ref MethodDeclaration,
-                                ref firstParameter,
-                                align,
-                                p.ParameterName,
-                                p.ParamModifier,
-                                p.TypeReference.Type);
-                        }
-
-                        MethodDeclaration += ");";
-                        ATemplate.AddToCodelet("CONTENT", MethodDeclaration + Environment.NewLine);
-                    }
-                }
-            }
-        }
-
-        return true;
-    }
-
-    /// <summary>
-    /// write the interfaces for the Connectors
-    /// parses the instantiator files
-    /// Although the instantiators are generated from the interfaces, they might contain ManualCode regions with specific functions
-    /// </summary>
-    /// <param name="ATemplate"></param>
-    /// <param name="AMethodsAlreadyWritten"></param>
-    /// <param name="AInstantiatorClasses">all instantiator classes that implement the interface</param>
-    /// <param name="AInterfaceName"></param>
-    /// <param name="AInterfaceNamespace"></param>
-    /// <param name="AServerNamespace">for the comment in the autogenerated code</param>
-    /// <returns></returns>
-    private bool WriteInstantiatorMethods(
-        ProcessTemplate ATemplate,
-        StringCollection AMethodsAlreadyWritten,
-        List <TypeDeclaration>AInstantiatorClasses, String AInterfaceName, String AInterfaceNamespace, String AServerNamespace)
-    {
-        foreach (TypeDeclaration t in AInstantiatorClasses)
-        {
-            // there should only be one class, eg. TSubscriptionsCacheableNamespace
-            foreach (MethodDeclaration m in CSParser.GetMethods(t))
-            {
-                // copy all public methods that are not constructor, destructor, or InitializeLifetimeService
-                // and that are not created yet
-                if ((m.Name != "InitializeLifetimeService")
-                    && ((m.Modifier & Modifiers.Public) != 0)
-                    && !AMethodsAlreadyWritten.Contains(m.Name))
-                {
-                    ATemplate.AddToCodelet("CONTENT",
-                        "/// <summary>auto generated from Instantiator (" + AServerNamespace + "." + t.Type + ")</summary>" + Environment.NewLine);
-                    string MethodDeclaration = AutoGenerationTools.TypeToString(m.TypeReference, "") + " " + m.Name + "(";
-                    int align = MethodDeclaration.Length;
-
-                    bool firstParameter = true;
-
-                    foreach (ParameterDeclarationExpression p in m.Parameters)
-                    {
-                        AutoGenerationTools.AddParameter(ref MethodDeclaration, ref firstParameter, align, p.ParameterName, p.ParamModifier,
-                            AutoGenerationTools.TypeToString(p.TypeReference, ""));
-                    }
-
-                    MethodDeclaration += ");";
-                    ATemplate.AddToCodelet("CONTENT", MethodDeclaration + Environment.NewLine);
-                }
-            }
-        }
-
-        return true;
-    }
-
     void WriteInterface(
         ProcessTemplate AMainTemplate,
         String ParentNamespace,
@@ -395,15 +233,6 @@
 
         snippet.SetCodelet("INTERFACENAME", AInterfaceName);
         snippet.SetCodelet("CONTENT", string.Empty);
-        snippet.SetCodelet("SUBNAMESPACES", string.Empty);
-
-        foreach (TNamespace child in children.Values)
-        {
-            ProcessTemplate snippetSubNamespace = AMainTemplate.GetSnippet("SUBNAMESPACE");
-            snippetSubNamespace.SetCodelet("SUBNAMESPACENAME", ParentInterfaceName + child.Name);
-            snippetSubNamespace.SetCodelet("SUBNAMESPACEOBJECT", child.Name);
-            snippet.InsertSnippet("SUBNAMESPACES", snippetSubNamespace);
-        }
 
         //this should return the Connector classes; the instantiator classes are in a different namespace
         string ServerConnectorNamespace = ParentNamespace.Replace("Ict.Petra.Shared.Interfaces", "Ict.Petra.Server");
@@ -411,27 +240,6 @@
         // don't write methods twice, once from Connector, and then again from Instantiator
         StringCollection MethodsAlreadyWritten = new StringCollection();
 
-        StringCollection InterfacesInNamespace = GetInterfacesInNamespace(ParentNamespace, InterfaceNames);
-
-        foreach (string ChildInterface in InterfacesInNamespace)
-        {
-            List <TypeDeclaration>ConnectorClasses = GetClassesThatImplementInterface(
-                ACSFiles,
-                ChildInterface,
-                ServerConnectorNamespace);
-
-            if (AInterfaceName.EndsWith("Namespace"))
-            {
-                WriteConnectorConstructors(
-                    snippet,
-                    ref MethodsAlreadyWritten,
-                    ConnectorClasses,
-                    ChildInterface,
-                    ParentNamespace,
-                    ServerConnectorNamespace);
-            }
-        }
-
         List <TypeDeclaration>ConnectorClasses2 = GetClassesThatImplementInterface(
             ACSFiles,
             AInterfaceName,
@@ -445,30 +253,6 @@
             ParentNamespace,
             ServerConnectorNamespace);
 
-        if (!ParentNamespace.Contains("WebConnector"))
-        {
-            // this is for the instantiator classes
-            StringCollection NamespaceSplit = StringHelper.StrSplit(ParentNamespace, ".");
-
-            // eg convert Ict.Petra.Shared.Interfaces.MPartner.Extracts.UIConnectors to Ict.Petra.Server.MPartner.Instantiator.Extracts.UIConnectors
-            NamespaceSplit[2] = "Server";
-            NamespaceSplit[3] = NamespaceSplit[4];
-            NamespaceSplit[4] = "Instantiator";
-            string ServerInstantiatorNamespace = StringHelper.StrMerge(NamespaceSplit, '.');
-            List <TypeDeclaration>InstantiatorClasses = GetClassesThatImplementInterface(
-                ACSFiles,
-                AInterfaceName,
-                ServerInstantiatorNamespace);
-
-            WriteInstantiatorMethods(
-                snippet,
-                MethodsAlreadyWritten,
-                InstantiatorClasses,
-                AInterfaceName,
-                ParentNamespace,
-                ServerInstantiatorNamespace);
-        }
-
         AMainTemplate.InsertSnippet("INTERFACES", snippet);
     }
 
@@ -508,13 +292,6 @@
         SortedList InterfaceNames,
         List <CSParser>ACSFiles)
     {
-        WriteInterface(
-            AMainTemplate,
-            ParentNamespace,
-            ParentInterfaceName,
-            "I" + ParentInterfaceName + "Namespace",
-            tn, sn, children, InterfaceNames, ACSFiles);
-
         StringCollection InterfacesInNamespace = GetInterfacesInNamespace(ParentNamespace, InterfaceNames);
 
         // has been written already; we want to keep the order of the interfaces this way
@@ -552,14 +329,6 @@
     {
         AMainTemplate.SetCodelet("MODULE", tn.Name);
 
-        foreach (TNamespace sn in tn.Children.Values)
-        {
-            ProcessTemplate snippet = AMainTemplate.GetSnippet("SUBNAMESPACE");
-            snippet.SetCodelet("SUBNAMESPACENAME", sn.Name);
-            snippet.SetCodelet("SUBNAMESPACEOBJECT", sn.Name);
-            AMainTemplate.InsertSnippet("SUBNAMESPACES", snippet);
-        }
-
         // parse Instantiator source code
         foreach (TNamespace sn in tn.Children.Values)
         {
@@ -628,8 +397,14 @@
 
         SortedList InterfaceNames = GetInterfaceNamesFromImplementation(CSFiles);
 
+        Template.SetCodelet("INTERFACES", string.Empty);
         WriteNamespaces(Template, tn, InterfaceNames, CSFiles);
 
+        if (Template.FCodelets["INTERFACES"].Length == 0)
+        {
+            Template.InsertSnippet("INTERFACES", Template.GetSnippet("DUMMYINTERFACE"));
+        }
+
         Template.FinishWriting(OutputFile, ".cs", true);
     }
 
