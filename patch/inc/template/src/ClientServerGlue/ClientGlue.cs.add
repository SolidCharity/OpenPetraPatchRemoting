// Auto generated by nant generateGlue
// From a template at inc\template\src\ClientServerGlue\ClientGlue.cs
//
// Do not modify this file manually!
//
{#GPLFILEHEADER}

using System;
using System.Threading;
using System.Data;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Specialized;
using Ict.Common;
using Ict.Common.Data;
using Ict.Common.Verification;
using Ict.Common.Remoting.Shared;
using Ict.Common.Remoting.Client;
using Ict.Petra.Shared;
{#USINGNAMESPACES}

namespace {#REMOTEOBJECTSNAMESPACE}
{
    /// the top level namespace for the module {#TOPLEVELMODULE}
    public class TM{#TOPLEVELMODULE}Namespace
    {
        {#SUBNAMESPACEPROPERTIES}
        {#SUBNAMESPACECLASSES}
    }
}

{##SUBNAMESPACEPROPERTY}
private T{#NAMESPACENAME}Namespace F{#NAMESPACENAME}Namespace = new T{#NAMESPACENAME}Namespace();

/// <summary>The '{#SUBNAMESPACENAME}' subnamespace contains further subnamespaces.</summary>
public T{#NAMESPACENAME}Namespace {#OBJECTNAME}
{
    get
    {
        return F{#NAMESPACENAME}Namespace;
    }
}

{##NAMESPACECLASS}
/// <summary> namespace definition </summary>
public class T{#NAMESPACENAME}Namespace
{
    {#CONNECTORMETHODS}
    {#SUBNAMESPACEPROPERTIES}
    {#SUBNAMESPACECLASSES}
}

{##WEBCONNECTORMETHODREMOTE}
/// forward the method call
public {#RETURNTYPE} {#METHODNAME}({#PARAMETERDEFINITION})
{
    SortedList<string, object> ActualParameters = new SortedList<string, object>();
    {#ADDACTUALPARAMETERS}
    {#RESULT}THttpConnector.CallWebConnector("M{#TOPLEVELMODULE}", "{#WEBCONNECTORCLASS}.{#UNIQUEMETHODNAME}", ActualParameters, "{#EXPECTEDRETURNTYPE}");
    {#ASSIGNRESULTANDRETURN}
}

{##WEBCONNECTORMETHODSTANDALONE}
/// forward the method call
public {#RETURNTYPE} {#METHODNAME}({#PARAMETERDEFINITION})
{
    // TODO: check permissions
    {#RETURN}{#WEBCONNECTORCLASS}.{#METHODNAME}({#ACTUALPARAMETERS});
}

{##UICONNECTORMETHODREMOTE}
/// create an object on the server side
public {#UICONNECTORINTERFACE} {#METHODNAME}({#PARAMETERDEFINITION})
{
    return new {#UICONNECTORCLASSNAME}({#ACTUALPARAMETERS});
}

{#UICONNECTORCLASS}

{##UICONNECTORCLASS}
/// <summary>
/// UIConnector '{#UICONNECTORCLASSNAME}': Client-side implementation.
/// </summary>
public class {#UICONNECTORCLASSNAME}: {#UICONNECTORINTERFACE}, IDisposable
{
    // Flag: Has Dispose already been called?
    private bool FIsDisposed = false;
    // ObjectID that got assigned to this UIConnector instance by the server-side UIConnector.
    private readonly string FObjectID = String.Empty;

    {#CONSTRUCTORS}

    #region Destructor and Dispose for the 'IDisposable pattern'
    
    /// <summary>
    /// Destructor for the 'IDisposable pattern'.
    /// </summary>
    ~{#UICONNECTORCLASSNAME}()
    {
        Dispose(false);
    }

    /// <summary>
    /// 'IDisposable pattern': Call this Method to release the UIConnector Object on the server side,  
    /// whereupon it is eligible for Garbage Collection on the server side.
    /// </summary>
    public void Dispose()
    {
        Dispose(true);
        
        // We don't want the Finalizer to run as this is no longer necessary. Also, the next call takes this Object
        // off in the Finalizer queue of the client-side Garbage Collector so it can be Garbage Collected earlier.
        GC.SuppressFinalize(this);    
    }

    /// <summary>
    /// 'IDisposable pattern': Protected implementation of Dispose Method. This Method overload is only 
    /// to be called by the Finalizer!
    /// </summary>
    protected virtual void Dispose(bool ADisposing)
    {
       if (FIsDisposed)
       {
          return;
       }
 
       if (ADisposing) 
       {
           TLogging.Log("UIConnector Disposal: {#UICONNECTORCLASSNAME} with ObjectID '" + FObjectID + "' gets disposed. Reason: manual Dispose() call.");
       }
       else
       {
           TLogging.Log("UIConnector Disposal: {#UICONNECTORCLASSNAME} with ObjectID '" + FObjectID + "' gets disposed. Reason: call from Finalizer!");
       }

       THttpConnector.DisconnectUIConnector("M{#TOPLEVELMODULE}", FObjectID);
       
       FIsDisposed = true;
    }
    
    #endregion


    {#METHODSANDPROPERTIES}
}

{##UICONNECTORCONSTRUCTOR}
/// <summary>
/// Constructor. Creates the server-side UIConnector Object.  
/// </summary>
public {#UICONNECTORCLASSNAME}({#PARAMETERDEFINITION})
{
    var ActualParameters = new SortedList<string, object>();
    {#ADDACTUALPARAMETERS}
    FObjectID = THttpConnector.CreateUIConnector("M{#TOPLEVELMODULE}", "{#METHODNAME}", ActualParameters);
}

{##UICONNECTORMETHOD}
/// access the UIConnector Method
public {#RETURNTYPE} {#METHODNAME}({#PARAMETERDEFINITION})
{
    SortedList<string, object> ActualParameters = new SortedList<string, object>();
    {#ADDACTUALPARAMETERS}
    {#RESULT}THttpConnector.CallUIConnectorMethod(FObjectID, "M{#TOPLEVELMODULE}", "{#UICONNECTORCLASSNAME}", "{#UNIQUEMETHODNAME}", ActualParameters, "{#EXPECTEDRETURNTYPE}");
    {#ASSIGNRESULTANDRETURN}
}

{##UICONNECTORPROPERTY}
/// access the UIConnector Property
public {#TYPE} {#NAME}
{
{#IFDEF GETTER}
    get
    {
        {#GETTER}
    }
{#ENDIF GETTER}
{#IFDEF SETTER}
    set
    {
        THttpConnector.WriteUIConnectorProperty(FObjectID, "M{#TOPLEVELMODULE}", "{#UICONNECTORCLASSNAME}", "{#NAME}", value);
    }
{#ENDIF SETTER}
}

{##UICONNECTORMETHODSTANDALONE}
/// forward the method call
public {#UICONNECTORINTERFACE} {#METHODNAME}({#PARAMETERDEFINITION})
{
    // TODO: check permissions
    return new {#UICONNECTORCLASSNAME}({#ACTUALPARAMETERS});
}