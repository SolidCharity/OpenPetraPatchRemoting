--- openpetra.freeze/csharp/ICT/Common/Remoting/Server/ClientManager.cs	2014-07-24 14:18:45.000000000 +0200
+++ openpetra.patched/csharp/ICT/Common/Remoting/Server/ClientManager.cs	2014-07-24 14:51:37.000000000 +0200
@@ -26,12 +26,11 @@
 using System.Configuration;
 using System.Data;
 using System.Reflection;
-using System.Runtime.Remoting;
-using System.Runtime.Remoting.Lifetime;
 using System.Security.Principal;
 using System.Resources;
 using GNU.Gettext;
 using Ict.Common;
+using Ict.Common.DB.Exceptions;
 using Ict.Common.Exceptions;
 using Ict.Common.Verification;
 using Ict.Common.Remoting.Shared;
@@ -59,7 +58,7 @@
     /// Clients and to request information about Clients.
     ///
     /// </summary>
-    public class TClientManager : MarshalByRefObject, IClientManagerInterface
+    public class TClientManager
     {
         #region Resourcestrings
 
@@ -71,31 +70,23 @@
 
         #endregion
 
-        /// <summary>Holds reference to an instance of TClientManager (for calls inside a static function)</summary>
-        private static TClientManager UClientManagerObj;
-
         /// <summary>Holds reference to an instance of TSystemDefaultsCache (for System Defaults lookups)</summary>
         private static ISystemDefaultsCache USystemDefaultsCache;
 
-        /// <summary>Holds reference to an instance of TCacheableTablesManager (for caching of DataTables)</summary>
-        private static ICacheableTablesManager UCacheableTablesManager;
-
         private static IUserManager UUserManager = null;
         private static IErrorLog UErrorLog = null;
         private static IMaintenanceLogonMessage UMaintenanceLogonMessage = null;
-        private static IClientAppDomainConnection UClientDomainManager = null;
 
         /// <summary>Used for ThreadLocking a critical part of the Client Connection code to make sure that this code is executed by exactly one Client at any given time</summary>
-        private static System.Object UConnectClientMonitor;
-
-        /// Holds a TRunningAppDomain object for each Client that is currently connected to the Petra Server. IMPORTANT: to access this SortedList in a threadsave manner using an IDictionaryEnumerator, it is important that this is done only within a
-        /// <summary>block of code that is encapsulated using Monitor.TryEnter(UClientObjects.SyncRoot)!!!</summary>
-        private static SortedList UClientObjects;
-
-        private DateTime FStartTime;
+        private static System.Object UConnectClientMonitor = new System.Object();
 
-        /// <summary>Holds a reference to the ClientManagerCallForwarder Object.</summary>
-        private static TClientManagerCallForwarder FClientManagerCallForwarder;
+        /// <summary>
+        /// Holds a TConnectedClient object for each Client that is currently connected to the Petra Server.
+        /// IMPORTANT: to access this SortedList in a threadsave manner using an IDictionaryEnumerator,
+        /// it is important that this is done only within a
+        /// block of code that is encapsulated using Monitor.TryEnter(UClientObjects.SyncRoot)!!!
+        /// </summary>
+        private static SortedList UClientObjects = SortedList.Synchronized(new SortedList());
 
         /// <summary>Holds the total number of Clients that connected to the Petra Server since the start of the Petra Server.</summary>
         private static System.Int32 FClientsConnectedTotal;
@@ -124,9 +115,9 @@
                             // Iterate over all Clients and count the ones that are currently connected
                             while (ClientEnum.MoveNext())
                             {
-                                TRunningAppDomain app = ((TRunningAppDomain)ClientEnum.Value);
+                                TConnectedClient app = ((TConnectedClient)ClientEnum.Value);
 
-                                if ((app.FAppDomainStatus == TAppDomainStatus.adsActive) || (app.FAppDomainStatus == TAppDomainStatus.adsIdle))
+                                if ((app.FAppDomainStatus == TSessionStatus.adsActive) || (app.FAppDomainStatus == TSessionStatus.adsIdle))
                                 {
                                     ClientCounter++;
                                 }
@@ -175,81 +166,6 @@
             }
         }
 
-
-        /// <summary>
-        /// Called by TClientDomainManager to queue a ClientTask for a certain Client.
-        ///
-        /// </summary>
-        /// <param name="AClientID">Server-assigned ID of the Client; use -1 to queue the
-        /// ClientTask to all Clients</param>
-        /// <param name="ATaskGroup">Group of the Task</param>
-        /// <param name="ATaskCode">Code of the Task (depending on the TaskGroup this can be
-        /// left empty)</param>
-        /// <param name="ATaskParameter1">Parameter #1 for the Task (depending on the TaskGroup
-        /// this can be left empty)</param>
-        /// <param name="ATaskParameter2">Parameter #2 for the Task (depending on the TaskGroup
-        /// this can be left empty)</param>
-        /// <param name="ATaskParameter3">Parameter #3 for the Task (depending on the TaskGroup
-        /// this can be left empty)</param>
-        /// <param name="ATaskParameter4">Parameter #4 for the Task (depending on the TaskGroup
-        /// this can be left empty)</param>
-        /// <param name="ATaskPriority">Priority of the Task</param>
-        /// <param name="AExceptClientID">Pass in a Server-assigned ID of the Client that should
-        /// not get the ClientTask in its queue. Makes sense only if -1 is used for the
-        /// AClientID parameter. Default is -1, which means no Client is excepted.</param>
-        /// <returns>The ClientID for which the ClientTask was queued (the last ClientID
-        /// in the list of Clients if -1 is submitted for AClientID). Error values
-        /// are: -1 if AClientID is identical with AExceptClientID, -2 if the
-        /// Client specified with AClientID is not in the list of Clients or
-        /// AClientID &lt;&gt; -1
-        /// </returns>
-        public Int32 QueueClientTaskFromClient(System.Int32 AClientID,
-            String ATaskGroup,
-            String ATaskCode,
-            System.Object ATaskParameter1,
-            System.Object ATaskParameter2,
-            System.Object ATaskParameter3,
-            System.Object ATaskParameter4,
-            System.Int16 ATaskPriority,
-            System.Int32 AExceptClientID)
-        {
-            return QueueClientTask(
-                AClientID, ATaskGroup, ATaskCode, ATaskParameter1, ATaskParameter2,
-                ATaskParameter3, ATaskParameter4, ATaskPriority, AExceptClientID);
-        }
-
-        /// <summary>
-        /// overload
-        /// </summary>
-        /// <param name="AClientID"></param>
-        /// <param name="ATaskGroup"></param>
-        /// <param name="ATaskCode"></param>
-        /// <param name="ATaskParameter1"></param>
-        /// <param name="ATaskParameter2"></param>
-        /// <param name="ATaskParameter3"></param>
-        /// <param name="ATaskParameter4"></param>
-        /// <param name="ATaskPriority"></param>
-        /// <returns></returns>
-        public Int32 QueueClientTaskFromClient(System.Int32 AClientID,
-            String ATaskGroup,
-            String ATaskCode,
-            System.Object ATaskParameter1,
-            System.Object ATaskParameter2,
-            System.Object ATaskParameter3,
-            System.Object ATaskParameter4,
-            System.Int16 ATaskPriority)
-        {
-            return QueueClientTaskFromClient(AClientID,
-                ATaskGroup,
-                ATaskCode,
-                ATaskParameter1,
-                ATaskParameter2,
-                ATaskParameter3,
-                ATaskParameter4,
-                ATaskPriority,
-                -1);
-        }
-
         /// make sure that not a null value is returned, but an empty string
         private static string ValueOrEmpty(string s)
         {
@@ -358,59 +274,17 @@
         }
 
         /// <summary>
-        /// Initialises variables.
-        ///
-        /// </summary>
-        /// <returns>void</returns>
-        public TClientManager()
-        {
-            FClientManagerCallForwarder = new TClientManagerCallForwarder(this);
-            UClientObjects = SortedList.Synchronized(new SortedList());
-
-            // Console.WriteLine('UClientObjects.IsSynchronized: ' + UClientObjects.IsSynchronized.ToString);
-            FStartTime = DateTime.Now;
-            UConnectClientMonitor = new System.Object();
-            UClientManagerObj = this;
-        }
-
-        /// <summary>
         /// initialize variables that are initialized from classes specific to the server, eg. with access to OpenPetra database
         /// </summary>
         public static void InitializeStaticVariables(ISystemDefaultsCache ASystemDefaultsCache,
-            ICacheableTablesManager ACacheableTablesManager,
             IUserManager AUserManager,
             IErrorLog AErrorLog,
-            IMaintenanceLogonMessage AMaintenanceLogonMessage,
-            IClientAppDomainConnection AClientDomainManager)
+            IMaintenanceLogonMessage AMaintenanceLogonMessage)
         {
             USystemDefaultsCache = ASystemDefaultsCache;
-            UCacheableTablesManager = ACacheableTablesManager;
             UUserManager = AUserManager;
             UErrorLog = AErrorLog;
             UMaintenanceLogonMessage = AMaintenanceLogonMessage;
-            UClientDomainManager = AClientDomainManager;
-        }
-
-        /// <summary>
-        /// destructor
-        /// </summary>
-        ~TClientManager()
-        {
-            if (TLogging.DL >= 5)
-            {
-                Console.WriteLine("TClientManager: Got collected after " + (new TimeSpan(
-                                                                                DateTime.Now.Ticks - FStartTime.Ticks)).ToString() + " seconds.");
-            }
-        }
-
-        /// <summary>
-        /// needed for remoting
-        /// </summary>
-        /// <returns></returns>
-        public override object InitializeLifetimeService()
-        {
-            // make sure that the TClientManager object exists until the Server stops!
-            return null;
         }
 
         /// <summary>
@@ -420,14 +294,12 @@
         /// <param name="APassword"></param>
         /// <param name="AClientComputerName"></param>
         /// <param name="AClientIPAddress"></param>
-        /// <param name="AProcessID"></param>
         /// <param name="ASystemEnabled"></param>
         /// <returns></returns>
         static public IPrincipal PerformLoginChecks(String AUserName,
             String APassword,
             String AClientComputerName,
             String AClientIPAddress,
-            out Int32 AProcessID,
             out Boolean ASystemEnabled)
         {
             IPrincipal ReturnValue;
@@ -444,7 +316,6 @@
                 // This function call will throw Exceptions if the User cannot be authenticated
                 ReturnValue = UUserManager.PerformUserAuthentication(AUserName,
                     APassword,
-                    out AProcessID,
                     out ASystemEnabled);
             }
             catch (EUserNotExistantException)
@@ -515,10 +386,10 @@
             try
             {
                 if ((UClientObjects.Contains((object)AClientID))
-                    && (((TRunningAppDomain)UClientObjects[(object)AClientID]).AppDomainStatus != TAppDomainStatus.adsStopped))
+                    && (((TConnectedClient)UClientObjects[(object)AClientID]).SessionStatus != TSessionStatus.adsStopped))
                 {
                     // this.DisconnectClient would not work here since we are executing inside a static function...
-                    ReturnValue = UClientManagerObj.DisconnectClient(AClientID, out ACantDisconnectReason);
+                    ReturnValue = TClientManager.DisconnectClient(AClientID, out ACantDisconnectReason);
                 }
                 else
                 {
@@ -536,61 +407,6 @@
         }
 
         /// <summary>
-        /// add a service that is offered by the appdomain, for single port remoting
-        /// </summary>
-        public void AddCrossDomainService(string ClientID, string ObjectURI, ICrossDomainService ObjectToRemote)
-        {
-            TCrossDomainMarshaller.AddService(ClientID, ObjectURI, ObjectToRemote);
-        }
-
-        /// <summary>
-        /// Called by TClientManager to queue a ClientTask for a certain Client.
-        ///
-        /// @comment The position in source code of this overload (*after* the first
-        /// overload) is important! If this overload is put *before* the first
-        /// overload, the Compiler won't compile the statement
-        /// 'TCacheableTablesManager.Create(@TClientManager.QueueClientTask)'
-        /// in the initialization section due to a Compiler bug (QualityCentral #7435)!
-        ///
-        /// </summary>
-        /// <param name="AClientID">Server-assigned ID of the Client; use -1 to queue the
-        /// ClientTask to all Clients</param>
-        /// <param name="ATaskGroup">Group of the Task</param>
-        /// <param name="ATaskCode">Code of the Task (depending on the TaskGroup this can be
-        /// left empty)</param>
-        /// <param name="ATaskPriority">Priority of the Task</param>
-        /// <param name="AExceptClientID">Pass in a Server-assigned ID of the Client that should
-        /// not get the ClientTask in its queue. Makes sense only if -1 is used for the
-        /// AClientID parameter. Default is -1, which means no Client is excepted.</param>
-        /// <returns>The ClientID for which the ClientTask was queued (the last ClientID
-        /// in the list of Clients if -1 is submitted for AClientID). Error values
-        /// are: -1 if AClientID is identical with AExceptClientID, -2 if the
-        /// Client specified with AClientID is not in the list of Clients or
-        /// AClientID &lt;&gt; -1
-        /// </returns>
-        public static Int32 QueueClientTask(System.Int32 AClientID,
-            String ATaskGroup,
-            String ATaskCode,
-            System.Int16 ATaskPriority,
-            System.Int32 AExceptClientID)
-        {
-            return QueueClientTask(AClientID, ATaskGroup, ATaskCode, null, null, null, null, ATaskPriority, AExceptClientID);
-        }
-
-        /// <summary>
-        /// overload
-        /// </summary>
-        /// <param name="AClientID"></param>
-        /// <param name="ATaskGroup"></param>
-        /// <param name="ATaskCode"></param>
-        /// <param name="ATaskPriority"></param>
-        /// <returns></returns>
-        public static Int32 QueueClientTask(System.Int32 AClientID, String ATaskGroup, String ATaskCode, System.Int16 ATaskPriority)
-        {
-            return QueueClientTask(AClientID, ATaskGroup, ATaskCode, ATaskPriority, -1);
-        }
-
-        /// <summary>
         /// Called by TClientManager to queue a ClientTask for a certain Client.
         ///
         /// </summary>
@@ -625,10 +441,10 @@
             System.Object ATaskParameter3,
             System.Object ATaskParameter4,
             System.Int16 ATaskPriority,
-            System.Int32 AExceptClientID)
+            System.Int32 AExceptClientID = -1)
         {
             Int32 ReturnValue;
-            TRunningAppDomain AppDomainEntry;
+            TConnectedClient SessionEntry;
             IDictionaryEnumerator ClientEnum;
 
             ReturnValue = -2;
@@ -651,14 +467,14 @@
                             // Iterate over all Clients that are currently connected
                             while (ClientEnum.MoveNext())
                             {
-                                AppDomainEntry = ((TRunningAppDomain)ClientEnum.Value);
+                                SessionEntry = ((TConnectedClient)ClientEnum.Value);
 
                                 // ...and the ClientID isn't the one to except from
-                                if ((AppDomainEntry.ClientID != AExceptClientID)
-                                    && ((AppDomainEntry.AppDomainStatus == TAppDomainStatus.adsActive)
-                                        || (AppDomainEntry.AppDomainStatus == TAppDomainStatus.adsIdle)))
+                                if ((SessionEntry.ClientID != AExceptClientID)
+                                    && ((SessionEntry.SessionStatus == TSessionStatus.adsActive)
+                                        || (SessionEntry.SessionStatus == TSessionStatus.adsIdle)))
                                 {
-                                    ReturnValue = AppDomainEntry.ClientAppDomainConnection.ClientTaskAdd(ATaskGroup,
+                                    ReturnValue = SessionEntry.FTasksManager.ClientTaskAdd(ATaskGroup,
                                         ATaskCode,
                                         ATaskParameter1,
                                         ATaskParameter2,
@@ -676,17 +492,17 @@
                 }
                 else
                 {
-                    AppDomainEntry = (TRunningAppDomain)UClientObjects[(object)AClientID];
+                    SessionEntry = (TConnectedClient)UClientObjects[(object)AClientID];
 
                     // Send Notification Message  if an AppDomain for the ClientID exists...
-                    if (AppDomainEntry != null)
+                    if (SessionEntry != null)
                     {
                         // ...and the ClientID isn't the one to except from
-                        if ((AppDomainEntry.ClientID != AExceptClientID)
-                            && ((AppDomainEntry.AppDomainStatus == TAppDomainStatus.adsActive)
-                                || (AppDomainEntry.AppDomainStatus == TAppDomainStatus.adsIdle)))
+                        if ((SessionEntry.ClientID != AExceptClientID)
+                            && ((SessionEntry.SessionStatus == TSessionStatus.adsActive)
+                                || (SessionEntry.SessionStatus == TSessionStatus.adsIdle)))
                         {
-                            ReturnValue = AppDomainEntry.ClientAppDomainConnection.ClientTaskAdd(ATaskGroup,
+                            ReturnValue = SessionEntry.FTasksManager.ClientTaskAdd(ATaskGroup,
                                 ATaskCode,
                                 ATaskParameter1,
                                 ATaskParameter2,
@@ -710,83 +526,6 @@
         }
 
         /// <summary>
-        /// overload
-        /// </summary>
-        /// <param name="AClientID"></param>
-        /// <param name="ATaskGroup"></param>
-        /// <param name="ATaskCode"></param>
-        /// <param name="ATaskParameter1"></param>
-        /// <param name="ATaskParameter2"></param>
-        /// <param name="ATaskParameter3"></param>
-        /// <param name="ATaskParameter4"></param>
-        /// <param name="ATaskPriority"></param>
-        /// <returns></returns>
-        public static Int32 QueueClientTask(System.Int32 AClientID,
-            String ATaskGroup,
-            String ATaskCode,
-            System.Object ATaskParameter1,
-            System.Object ATaskParameter2,
-            System.Object ATaskParameter3,
-            System.Object ATaskParameter4,
-            System.Int16 ATaskPriority)
-        {
-            return QueueClientTask(AClientID,
-                ATaskGroup,
-                ATaskCode,
-                ATaskParameter1,
-                ATaskParameter2,
-                ATaskParameter3,
-                ATaskParameter4,
-                ATaskPriority,
-                -1);
-        }
-
-        /// <summary>
-        /// overload
-        /// </summary>
-        /// <param name="AUserID"></param>
-        /// <param name="ATaskGroup"></param>
-        /// <param name="ATaskCode"></param>
-        /// <param name="ATaskPriority"></param>
-        /// <returns></returns>
-        public static Int32 QueueClientTask(String AUserID, String ATaskGroup, String ATaskCode, System.Int16 ATaskPriority)
-        {
-            return QueueClientTask(AUserID, ATaskGroup, ATaskCode, ATaskPriority);
-        }
-
-        /// <summary>
-        /// overload
-        /// </summary>
-        /// <param name="AUserID"></param>
-        /// <param name="ATaskGroup"></param>
-        /// <param name="ATaskCode"></param>
-        /// <param name="ATaskParameter1"></param>
-        /// <param name="ATaskParameter2"></param>
-        /// <param name="ATaskParameter3"></param>
-        /// <param name="ATaskParameter4"></param>
-        /// <param name="ATaskPriority"></param>
-        /// <returns></returns>
-        public static Int32 QueueClientTask(String AUserID,
-            String ATaskGroup,
-            String ATaskCode,
-            System.Object ATaskParameter1,
-            System.Object ATaskParameter2,
-            System.Object ATaskParameter3,
-            System.Object ATaskParameter4,
-            System.Int16 ATaskPriority)
-        {
-            return QueueClientTask(AUserID,
-                ATaskGroup,
-                ATaskCode,
-                ATaskParameter1,
-                ATaskParameter2,
-                ATaskParameter3,
-                ATaskParameter4,
-                ATaskPriority,
-                -1);
-        }
-
-        /// <summary>
         /// add client task to queue
         /// </summary>
         /// <param name="AUserID"></param>
@@ -811,7 +550,6 @@
         {
             Int32 ReturnValue;
             IDictionaryEnumerator ClientEnum;
-            TRunningAppDomain AppDomainEntry;
 
             ReturnValue = -2;
             ClientEnum = UClientObjects.GetEnumerator();
@@ -823,24 +561,24 @@
                     // Iterate over all Clients that are currently connected
                     while (ClientEnum.MoveNext())
                     {
-                        AppDomainEntry = (TRunningAppDomain)ClientEnum.Value;
+                        TConnectedClient SessionEntry = (TConnectedClient)ClientEnum.Value;
 
                         // Process Clients whose UserID is the one we look for
-                        if (AppDomainEntry.UserID == AUserID)
+                        if (SessionEntry.UserID == AUserID)
                         {
                             // ...and the ClientID isn't the one to except from
-                            if ((AppDomainEntry.ClientID != AExceptClientID)
-                                && ((AppDomainEntry.AppDomainStatus == TAppDomainStatus.adsActive)
-                                    || (AppDomainEntry.AppDomainStatus == TAppDomainStatus.adsIdle)))
+                            if ((SessionEntry.ClientID != AExceptClientID)
+                                && ((SessionEntry.SessionStatus == TSessionStatus.adsActive)
+                                    || (SessionEntry.SessionStatus == TSessionStatus.adsIdle)))
                             {
                                 if (TLogging.DL >= 5)
                                 {
                                     Console.WriteLine(
                                         "TClientManager.QueueClientTask: queuing Task for UserID '" + AUserID + "' (ClientID: " +
-                                        AppDomainEntry.ClientID.ToString());
+                                        SessionEntry.ClientID.ToString());
                                 }
 
-                                ReturnValue = QueueClientTask(AppDomainEntry.ClientID,
+                                ReturnValue = QueueClientTask(SessionEntry.ClientID,
                                     ATaskGroup,
                                     ATaskCode,
                                     ATaskParameter1,
@@ -866,186 +604,15 @@
         }
 
         /// <summary>
-        /// Called by TClientDomainManager to queue a ClientTask for a certain Client.
-        ///
-        /// </summary>
-        /// <param name="AClientID">Server-assigned ID of the Client; use -1 to queue the
-        /// ClientTask to all Clients</param>
-        /// <param name="ATaskGroup">Group of the Task</param>
-        /// <param name="ATaskCode">Code of the Task</param>
-        /// <param name="ATaskPriority">Priority of the Task</param>
-        /// <param name="AExceptClientID">Pass in a Server-assigned ID of the Client that should
-        /// not get the ClientTask in its queue. Makes sense only if -1 is used for the
-        /// AClientID parameter. Default is -1, which means no Client is excepted.</param>
-        /// <returns>The ClientID for which the ClientTask was queued (the last ClientID
-        /// in the list of Clients if -1 is submitted for AClientID). Error values
-        /// are: -1 if AClientID is identical with AExceptClientID, -2 if the
-        /// Client specified with AClientID is not in the list of Clients or
-        /// AClientID &lt;&gt; -1
-        /// </returns>
-        public Int32 QueueClientTaskFromClient(System.Int32 AClientID,
-            String ATaskGroup,
-            String ATaskCode,
-            System.Int16 ATaskPriority,
-            System.Int32 AExceptClientID)
-        {
-            return QueueClientTask(AClientID, ATaskGroup, ATaskCode, null, null, null, null, ATaskPriority, AExceptClientID);
-        }
-
-        /// <summary>
-        /// overload
-        /// </summary>
-        /// <param name="AClientID"></param>
-        /// <param name="ATaskGroup"></param>
-        /// <param name="ATaskCode"></param>
-        /// <param name="ATaskPriority"></param>
-        /// <returns></returns>
-        public Int32 QueueClientTaskFromClient(System.Int32 AClientID, String ATaskGroup, String ATaskCode, System.Int16 ATaskPriority)
-        {
-            return QueueClientTaskFromClient(AClientID, ATaskGroup, ATaskCode, ATaskPriority, -1);
-        }
-
-        /// <summary>
-        /// Called by TClientDomainManager to queue a ClientTask for a certain UserID.
-        ///
-        /// @comment If a User is several times connected, all Client instances for that UserID
-        /// will get the ClientTask queued.
-        ///
-        /// </summary>
-        /// <param name="AUserID">UserID for which the ClientTask should be queued</param>
-        /// <param name="ATaskGroup">Group of the Task</param>
-        /// <param name="ATaskCode">Code of the Task</param>
-        /// <param name="ATaskPriority">Priority of the Task</param>
-        /// <param name="AExceptClientID">Pass in a Server-assigned ID of the Client that should
-        /// not get the ClientTask in its queue. Makes sense only if -1 is used for the
-        /// AClientID parameter. Default is -1, which means no Client is excepted.</param>
-        /// <returns>The ClientID for which the ClientTask was queued (the last ClientID
-        /// in the list of Clients if -1 is submitted for AClientID). Error values
-        /// are: -1 if AClientID is identical with AExceptClientID, -2 if the
-        /// Client specified with AClientID is not in the list of Clients or
-        /// AClientID &lt;&gt; -1
-        /// </returns>
-        public Int32 QueueClientTaskFromClient(String AUserID,
-            String ATaskGroup,
-            String ATaskCode,
-            System.Int16 ATaskPriority,
-            System.Int32 AExceptClientID)
-        {
-            return QueueClientTask(AUserID, ATaskGroup, ATaskCode, null, null, null, null, ATaskPriority, AExceptClientID);
-        }
-
-        /// <summary>
-        /// overload
-        /// </summary>
-        /// <param name="AUserID"></param>
-        /// <param name="ATaskGroup"></param>
-        /// <param name="ATaskCode"></param>
-        /// <param name="ATaskPriority"></param>
-        /// <returns></returns>
-        public Int32 QueueClientTaskFromClient(String AUserID, String ATaskGroup, String ATaskCode, System.Int16 ATaskPriority)
-        {
-            return QueueClientTaskFromClient(AUserID, ATaskGroup, ATaskCode, ATaskPriority, -1);
-        }
-
-        /// <summary>
-        /// Called by TClientDomainManager to queue a ClientTask for a certain UserID.
-        ///
-        /// @comment If a User is several times connected, all Client instances for that UserID
-        /// will get the ClientTask queued.
-        ///
-        /// </summary>
-        /// <param name="AUserID">UserID for which the ClientTask should be queued</param>
-        /// <param name="ATaskGroup">Group of the Task</param>
-        /// <param name="ATaskCode">Code of the Task (depending on the TaskGroup this can be
-        /// left empty)</param>
-        /// <param name="ATaskParameter1">Parameter #1 for the Task (depending on the TaskGroup
-        /// this can be left empty)</param>
-        /// <param name="ATaskParameter2">Parameter #2 for the Task (depending on the TaskGroup
-        /// this can be left empty)</param>
-        /// <param name="ATaskParameter3">Parameter #3 for the Task (depending on the TaskGroup
-        /// this can be left empty)</param>
-        /// <param name="ATaskParameter4">Parameter #4 for the Task (depending on the TaskGroup
-        /// this can be left empty)</param>
-        /// <param name="ATaskPriority">Priority of the Task</param>
-        /// <param name="AExceptClientID">Pass in a Server-assigned ID of the Client that should
-        /// not get the ClientTask in its queue. Makes sense only if -1 is used for the
-        /// AClientID parameter. Default is -1, which means no Client is excepted.</param>
-        /// <returns>The ClientID for which the ClientTask was queued (the last ClientID
-        /// in the list of Clients if -1 is submitted for AClientID). Error values
-        /// are: -1 if AClientID is identical with AExceptClientID, -2 if the
-        /// Client specified with AClientID is not in the list of Clients or
-        /// AClientID &lt;&gt; -1
-        /// </returns>
-        public Int32 QueueClientTaskFromClient(String AUserID,
-            String ATaskGroup,
-            String ATaskCode,
-            object ATaskParameter1,
-            object ATaskParameter2,
-            object ATaskParameter3,
-            object ATaskParameter4,
-            System.Int16 ATaskPriority,
-            System.Int32 AExceptClientID)
-        {
-            return QueueClientTask(AUserID,
-                ATaskGroup,
-                ATaskCode,
-                ATaskParameter1,
-                ATaskParameter2,
-                ATaskParameter3,
-                ATaskParameter4,
-                ATaskPriority,
-                AExceptClientID);
-        }
-
-        /// <summary>
-        /// overload
-        /// </summary>
-        /// <param name="AUserID"></param>
-        /// <param name="ATaskGroup"></param>
-        /// <param name="ATaskCode"></param>
-        /// <param name="ATaskParameter1"></param>
-        /// <param name="ATaskParameter2"></param>
-        /// <param name="ATaskParameter3"></param>
-        /// <param name="ATaskParameter4"></param>
-        /// <param name="ATaskPriority"></param>
-        /// <returns></returns>
-        public Int32 QueueClientTaskFromClient(String AUserID,
-            String ATaskGroup,
-            String ATaskCode,
-            object ATaskParameter1,
-            object ATaskParameter2,
-            object ATaskParameter3,
-            object ATaskParameter4,
-            System.Int16 ATaskPriority)
-        {
-            return QueueClientTaskFromClient(AUserID,
-                ATaskGroup,
-                ATaskCode,
-                ATaskParameter1,
-                ATaskParameter2,
-                ATaskParameter3,
-                ATaskParameter4,
-                ATaskPriority,
-                -1);
-        }
-
-        /// <summary>
         /// add error to log, using IErrorLog
         /// </summary>
-        /// <param name="AErrorCode"></param>
-        /// <param name="AContext"></param>
-        /// <param name="AMessageLine1"></param>
-        /// <param name="AMessageLine2"></param>
-        /// <param name="AMessageLine3"></param>
-        /// <param name="AUserID"></param>
-        /// <param name="AProcessID"></param>
-        public void AddErrorLogEntry(String AErrorCode,
+        public static void AddErrorLogEntry(String AErrorCode,
             String AContext,
             String AMessageLine1,
             String AMessageLine2,
             String AMessageLine3,
-            String AUserID,
-            Int32 AProcessID)
+            Int32 AProcessID,
+            String AUserID)
         {
             if (UErrorLog != null)
             {
@@ -1092,20 +659,18 @@
                             // Iterate over all Clients
                             while (ClientEnum.MoveNext())
                             {
-                                TRunningAppDomain app = ((TRunningAppDomain)ClientEnum.Value);
+                                TConnectedClient app = ((TConnectedClient)ClientEnum.Value);
 
                                 if (((AListDisconnectedClients)
-                                     && ((app.FAppDomainStatus == TAppDomainStatus.adsActive)
-                                         || (app.FAppDomainStatus == TAppDomainStatus.adsIdle)
-                                         || (app.FAppDomainStatus == TAppDomainStatus.adsConnectingLoginVerification)
-                                         || (app.FAppDomainStatus == TAppDomainStatus.adsConnectingLoginOK)
-                                         || (app.FAppDomainStatus == TAppDomainStatus.adsConnectingAppDomainSetupOK)))
+                                     && ((app.FAppDomainStatus == TSessionStatus.adsActive)
+                                         || (app.FAppDomainStatus == TSessionStatus.adsIdle)
+                                         || (app.FAppDomainStatus == TSessionStatus.adsConnectingLoginVerification)
+                                         || (app.FAppDomainStatus == TSessionStatus.adsConnectingLoginOK)))
                                     || ((!AListDisconnectedClients)
-                                        && (!((app.FAppDomainStatus == TAppDomainStatus.adsActive)
-                                              || (app.FAppDomainStatus == TAppDomainStatus.adsIdle)
-                                              || (app.FAppDomainStatus == TAppDomainStatus.adsConnectingLoginVerification)
-                                              || (app.FAppDomainStatus == TAppDomainStatus.adsConnectingLoginOK)
-                                              || (app.FAppDomainStatus == TAppDomainStatus.adsConnectingAppDomainSetupOK)))))
+                                        && (!((app.FAppDomainStatus == TSessionStatus.adsActive)
+                                              || (app.FAppDomainStatus == TSessionStatus.adsIdle)
+                                              || (app.FAppDomainStatus == TSessionStatus.adsConnectingLoginVerification)
+                                              || (app.FAppDomainStatus == TSessionStatus.adsConnectingLoginOK)))))
                                 {
                                     // Client has got the wrong AppDomainStatus > skip it
                                     continue;
@@ -1115,11 +680,11 @@
 
                                 LastActionTime = DateTime.MinValue;
 
-                                if ((app.FAppDomainStatus == TAppDomainStatus.adsActive) || (app.FAppDomainStatus == TAppDomainStatus.adsIdle))
+                                if ((app.FAppDomainStatus == TSessionStatus.adsActive) || (app.FAppDomainStatus == TSessionStatus.adsIdle))
                                 {
                                     try
                                     {
-                                        LastActionTime = app.FClientAppDomainConnection.LastActionTime;
+                                        LastActionTime = app.LastActionTime;
                                     }
                                     catch (System.Runtime.Remoting.RemotingException)
                                     {
@@ -1132,22 +697,17 @@
                                 }
 
                                 // Determine/update Client AppDomain's Status
-                                if (app.FAppDomainStatus == TAppDomainStatus.adsConnectingLoginVerification)
+                                if (app.FAppDomainStatus == TSessionStatus.adsConnectingLoginVerification)
                                 {
                                     AppDomainStatusString = "Connecting...(1)";
                                     LastClientAction = app.FClientConnectionStartTime;
                                 }
-                                else if (app.FAppDomainStatus == TAppDomainStatus.adsConnectingLoginOK)
+                                else if (app.FAppDomainStatus == TSessionStatus.adsConnectingLoginOK)
                                 {
                                     AppDomainStatusString = "Connecting...(2)";
                                     LastClientAction = app.FClientConnectionStartTime;
                                 }
-                                else if (app.FAppDomainStatus == TAppDomainStatus.adsConnectingAppDomainSetupOK)
-                                {
-                                    AppDomainStatusString = "Connecting...(3)";
-                                    LastClientAction = app.FClientConnectionStartTime;
-                                }
-                                else if (app.FAppDomainStatus == TAppDomainStatus.adsActive)
+                                else if (app.FAppDomainStatus == TSessionStatus.adsActive)
                                 {
                                     if (LastActionTime.AddMinutes(1) > DateTime.Now)
                                     {
@@ -1157,11 +717,11 @@
                                     else
                                     {
                                         AppDomainStatusString = "Idle";
-                                        app.FAppDomainStatus = TAppDomainStatus.adsIdle;
+                                        app.FAppDomainStatus = TSessionStatus.adsIdle;
                                         LastClientAction = LastActionTime;
                                     }
                                 }
-                                else if (app.FAppDomainStatus == TAppDomainStatus.adsIdle)
+                                else if (app.FAppDomainStatus == TSessionStatus.adsIdle)
                                 {
                                     if (LastActionTime.AddMinutes(1) < DateTime.Now)
                                     {
@@ -1171,21 +731,16 @@
                                     else
                                     {
                                         AppDomainStatusString = "Active";
-                                        app.FAppDomainStatus = TAppDomainStatus.adsActive;
+                                        app.FAppDomainStatus = TSessionStatus.adsActive;
                                         LastClientAction = LastActionTime;
                                     }
                                 }
-                                else if (app.FAppDomainStatus == TAppDomainStatus.adsDisconnectingDBClosing)
+                                else if (app.FAppDomainStatus == TSessionStatus.adsDisconnectingDBClosing)
                                 {
                                     AppDomainStatusString = "Disconnecting(1)";
                                     LastClientAction = app.FClientDisconnectionStartTime;
                                 }
-                                else if (app.FAppDomainStatus == TAppDomainStatus.adsDisconnectingAppDomainUnloading)
-                                {
-                                    AppDomainStatusString = "Disconnecting(2)";
-                                    LastClientAction = app.FClientDisconnectionStartTime;
-                                }
-                                else if (app.FAppDomainStatus == TAppDomainStatus.adsStopped)
+                                else if (app.FAppDomainStatus == TSessionStatus.adsStopped)
                                 {
                                     AppDomainStatusString = "Disconnected!";
                                     LastClientAction = app.FClientDisconnectionFinishedTime;
@@ -1266,15 +821,10 @@
             return BuildClientList(AListDisconnectedClients);
         }
 
-        /// name for the cross domain url
-        public static string CROSSDOMAINURL = "services";
-
         /// <summary>
         /// Called by a Client to request connection to the Petra Server.
         ///
-        /// Creates an AppDomain, loads Petra Module DLL's into it and returns
-        /// .NET Remoting URLs for intantiated objects that represent the Petra Module
-        /// Root Namespaces (eg. MPartner, MFinance).
+        /// Authenticate the user and create a sesssion for the user.
         ///
         /// </summary>
         /// <param name="AUserName">Username with which the Client connects</param>
@@ -1283,43 +833,22 @@
         /// <param name="AClientExeVersion"></param>
         /// <param name="AClientIPAddress">IP Address of the Client</param>
         /// <param name="AClientServerConnectionType">Type of the connection (eg. LAN, Remote)</param>
-        /// <param name="AClientName">Server-assigned Name of the Client</param>
         /// <param name="AClientID">Server-assigned ID of the Client</param>
-        /// <param name="ACrossDomainURL">there is only one url now for connecting to the services</param>
-        /// <param name="ARemotingURLs">A HashTable containing .NET Remoting URLs of the Petra
-        /// Module Root Namespaces (eg. MPartner, MFinance) and other important objects
-        /// that need to be called from the Client.</param>
-        /// <param name="AServerOS">Operating System that the Server is running on
-        /// </param>
-        /// <param name="AProcessID"></param>
         /// <param name="AWelcomeMessage"></param>
         /// <param name="ASystemEnabled"></param>
         /// <param name="AUserInfo"></param>
-        /// <returns>void</returns>
-        public void ConnectClient(String AUserName,
+        public static TConnectedClient ConnectClient(String AUserName,
             String APassword,
             String AClientComputerName,
             String AClientIPAddress,
             System.Version AClientExeVersion,
             TClientServerConnectionType AClientServerConnectionType,
-            out String AClientName,
             out System.Int32 AClientID,
-            out string ACrossDomainURL,
-            out Hashtable ARemotingURLs,
-            out TExecutingOSEnum AServerOS,
-            out Int32 AProcessID,
             out String AWelcomeMessage,
             out Boolean ASystemEnabled,
             out IPrincipal AUserInfo)
         {
-            String LoadInAppDomainName;
-            IClientAppDomainConnection ClientDomainManager = null;
-            String RemotingURL_RemotedObject = "";
-            String RemotingURL_PollClientTasks;
-            TRunningAppDomain AppDomainEntry;
-            String CantDisconnectReason;
-
-            ACrossDomainURL = CROSSDOMAINURL;
+            TConnectedClient ConnectedClient = null;
 
             if (TLogging.DL >= 10)
             {
@@ -1341,7 +870,7 @@
              */
             try
             {
-                if (Monitor.TryEnter(UConnectClientMonitor, TSrvSetting.ClientConnectionTimeoutAfterXSeconds * 1000))
+                // TODORemoting if (Monitor.TryEnter(UConnectClientMonitor, TSrvSetting.ClientConnectionTimeoutAfterXSeconds * 1000))
                 {
                     #region Logging
 
@@ -1362,21 +891,18 @@
 
                     #endregion
                     #region Variable assignments
-                    ARemotingURLs = new Hashtable(6);
                     AClientID = (short)FClientsConnectedTotal;
                     FClientsConnectedTotal++;
-                    AClientName = AUserName.ToUpper() + "_" + AClientID.ToString();
-                    AServerOS = TSrvSetting.ExecutingOS;
-                    LoadInAppDomainName = AClientName + "_Domain";
+                    string ClientName = AUserName.ToUpper() + "_" + AClientID.ToString();
                     #endregion
                     try
                     {
                         if (Monitor.TryEnter(UClientObjects.SyncRoot))
                         {
+                            ConnectedClient = new TConnectedClient(AClientID, AUserName.ToUpper(), ClientName, AClientComputerName, AClientIPAddress,
+                                AClientServerConnectionType, ClientName);
                             // Add the new Client to UClientObjects SortedList
-                            UClientObjects.Add((object)AClientID,
-                                new TRunningAppDomain(AClientID, AUserName.ToUpper(), AClientName, AClientComputerName, AClientIPAddress,
-                                    AClientServerConnectionType, LoadInAppDomainName));
+                            UClientObjects.Add((object)AClientID, ConnectedClient);
                         }
                     }
                     finally
@@ -1395,7 +921,7 @@
 
                     if (TSrvSetting.ApplicationVersion.Compare(new TFileVersionInfo(AClientExeVersion)) != 0)
                     {
-                        ((TRunningAppDomain)UClientObjects[(object)AClientID]).AppDomainStatus = TAppDomainStatus.adsStopped;
+                        ConnectedClient.SessionStatus = TSessionStatus.adsStopped;
                         #region Logging
 
                         if (TLogging.DL >= 4)
@@ -1427,7 +953,6 @@
                             APassword,
                             AClientComputerName,
                             AClientIPAddress,
-                            out AProcessID,
                             out ASystemEnabled);
                     }
                     catch (EPetraSecurityException)
@@ -1447,18 +972,20 @@
                         }
 
                         #endregion
-                        ((TRunningAppDomain)UClientObjects[(object)AClientID]).AppDomainStatus = TAppDomainStatus.adsStopped;
+                        ConnectedClient.SessionStatus = TSessionStatus.adsStopped;
                         throw;
                     }
                     catch (Exception)
                     {
-                        ((TRunningAppDomain)UClientObjects[(object)AClientID]).AppDomainStatus = TAppDomainStatus.adsStopped;
+                        ConnectedClient.SessionStatus = TSessionStatus.adsStopped;
                         throw;
                     }
                     #endregion
 
                     // Login Checks were successful!
-                    ((TRunningAppDomain)UClientObjects[(object)AClientID]).AppDomainStatus = TAppDomainStatus.adsConnectingLoginOK;
+                    ConnectedClient.SessionStatus = TSessionStatus.adsConnectingLoginOK;
+
+                    #endregion
 
                     // Retrieve Welcome message
                     try
@@ -1474,107 +1001,9 @@
                     }
                     catch (Exception)
                     {
-                        ((TRunningAppDomain)UClientObjects[(object)AClientID]).AppDomainStatus = TAppDomainStatus.adsStopped;
-                        throw;
-                    }
-
-                    if (TLogging.DL >= 10)
-                    {
-                        TLogging.Log(
-                            "Loaded Assemblies in AppDomain " + Thread.GetDomain().FriendlyName + " (before new AppDomain load):",
-                            TLoggingType.ToConsole | TLoggingType.ToLogfile);
-
-                        foreach (Assembly tmpAssembly in Thread.GetDomain().GetAssemblies())
-                        {
-                            TLogging.Log(tmpAssembly.FullName, TLoggingType.ToConsole | TLoggingType.ToLogfile);
-                        }
-                    }
-
-                    #region Create new AppDomain for Client, load ClientDomain DLL into it, initialise AppDomain
-                    try
-                    {
-                        try
-                        {
-                            // The following statement creates a new AppDomain for the connecting
-                            // Client and remotes an instance of TRemoteLoader into it.
-                            ClientDomainManager = UClientDomainManager.CreateAppDomain(AClientName);
-
-                            if (TLogging.DL >= 10)
-                            {
-                                TLogging.Log(
-                                    "Loaded Assemblies in AppDomain " + Thread.GetDomain().FriendlyName +
-                                    ": (after TClientAppDomainConnection.Create)",
-                                    TLoggingType.ToConsole | TLoggingType.ToLogfile);
-
-                                foreach (Assembly tmpAssembly in Thread.GetDomain().GetAssemblies())
-                                {
-                                    TLogging.Log(tmpAssembly.FullName, TLoggingType.ToConsole | TLoggingType.ToLogfile);
-                                }
-                            }
-
-                            // The following statement loads the ClientDomain DLL into the Client's
-                            // AppDomain, instantiates the main Class and initialises the AppDomain
-                            ClientDomainManager.LoadDomainManagerAssembly(AClientID,
-                                AClientServerConnectionType,
-                                FClientManagerCallForwarder,
-                                USystemDefaultsCache,
-                                UCacheableTablesManager,
-                                AUserInfo,
-                                out RemotingURL_PollClientTasks);
-                            ARemotingURLs.Add(RemotingConstants.REMOTINGURL_IDENTIFIER_POLLCLIENTTASKS, RemotingURL_PollClientTasks);
-                        }
-                        catch (TargetInvocationException exp)
-                        {
-                            TLogging.Log(
-                                "Error while creating new AppDomain for Client! Exception: " +
-                                exp.ToString() +
-                                "\r\n" + "InnerException: " + exp.InnerException.ToString());
-                            throw exp.InnerException;
-                        }
-                        catch (Exception exp)
-                        {
-                            TLogging.Log(
-                                "Error while creating new AppDomain for Client! Exception: " + exp.ToString());
-                            throw;
-                        }
-                    }
-                    catch (Exception)
-                    {
-                        // we should cleanly shut down the appdomain, to avoid exception:
-                        // System.Net.Sockets.SocketException: Address already in use
-                        AppDomainEntry = (TRunningAppDomain)UClientObjects[(object)AClientID];
-
-                        if ((AppDomainEntry == null) || (ClientDomainManager == null))
-                        {
-                            // Application domain was not setup yet
-                            AppDomainEntry.AppDomainStatus = TAppDomainStatus.adsStopped;
-                        }
-                        else
-                        {
-                            AppDomainEntry.PassInClientRemotingInfo(RemotingURL_RemotedObject, ClientDomainManager);
-                            ServerDisconnectClient(AClientID, out CantDisconnectReason);
-                        }
-
+                        ConnectedClient.SessionStatus = TSessionStatus.adsStopped;
                         throw;
                     }
-                    #endregion
-
-                    if (TLogging.DL >= 10)
-                    {
-                        TLogging.Log(
-                            "Loaded Assemblies in AppDomain " + Thread.GetDomain().FriendlyName + " (after new AppDomain load):",
-                            TLoggingType.ToConsole |
-                            TLoggingType.ToLogfile);
-
-                        foreach (Assembly tmpAssembly in Thread.GetDomain().GetAssemblies())
-                        {
-                            TLogging.Log(tmpAssembly.FullName, TLoggingType.ToConsole | TLoggingType.ToLogfile);
-                        }
-                    }
-
-                    ((TRunningAppDomain)UClientObjects[(object)AClientID]).PassInClientRemotingInfo(RemotingURL_RemotedObject,
-                        ClientDomainManager);
-                    ((TRunningAppDomain)UClientObjects[(object)AClientID]).AppDomainStatus = TAppDomainStatus.adsConnectingAppDomainSetupOK;
 
                     /*
                      * Uncomment the following statement to be able to better test how the
@@ -1588,27 +1017,23 @@
                      * Notify all waiting Clients (that have not timed out yet) that they can
                      * now try to connect...
                      */
-                    Monitor.PulseAll(UConnectClientMonitor);
+                    // TODORemoting Monitor.PulseAll(UConnectClientMonitor);
                 }
-                else
+// TODORemoting               else
                 {
                     /*
                      * Throw Exception to tell any timed-out connecting Client that the Server
                      * is too busy to accept connect requests at the moment.
                      */
-                    throw new ELoginFailedServerTooBusyException();
+// TODORemoting                   throw new ELoginFailedServerTooBusyException();
                 }
             }
             finally
             {
-                Monitor.Exit(UConnectClientMonitor);
+// TODORemoting               Monitor.Exit(UConnectClientMonitor);
             }
 
-            ClientDomainManager.LoadAssemblies(AClientID.ToString(), AUserInfo, ref ARemotingURLs);
-
-            ((TRunningAppDomain)UClientObjects[(object)AClientID]).AppDomainStatus = TAppDomainStatus.adsActive;
-            ((TRunningAppDomain)UClientObjects[(object)AClientID]).FClientConnectionFinishedTime = DateTime.Now;
-
+            ConnectedClient.StartSession(new TDelegateTearDownAppDomain(DisconnectClient));
 
             #region Logging
 
@@ -1619,8 +1044,8 @@
             {
                 TLogging.Log(
                     "Client '" + AUserName + "' successfully connected (took " +
-                    ((TRunningAppDomain)UClientObjects[(object)AClientID]).FClientConnectionFinishedTime.Subtract(
-                        ((TRunningAppDomain)UClientObjects[(object)AClientID]).FClientConnectionStartTime).
+                    ConnectedClient.FClientConnectionFinishedTime.Subtract(
+                        ((TConnectedClient)UClientObjects[(object)AClientID]).FClientConnectionStartTime).
                     TotalSeconds.ToString() + " sec). ClientID: " + AClientID.ToString(),
                     TLoggingType.ToConsole | TLoggingType.ToLogfile);
             }
@@ -1630,6 +1055,40 @@
             }
 
             #endregion
+            return ConnectedClient;
+        }
+
+        /// <summary>
+        /// convert exception to error code
+        /// </summary>
+        public static eLoginEnum LoginErrorFromException(Exception e)
+        {
+            if (e is EUserNotExistantException || e is EAccessDeniedException)
+            {
+                return eLoginEnum.eLoginAuthenticationFailed;
+            }
+            else if (e is EUserRetiredException)
+            {
+                return eLoginEnum.eLoginUserIsRetired;
+            }
+            else if (e is ESystemDisabledException)
+            {
+                return eLoginEnum.eLoginSystemDisabled;
+            }
+            else if (e is EClientVersionMismatchException)
+            {
+                return eLoginEnum.eLoginVersionMismatch;
+            }
+            else if (e is ELoginFailedServerTooBusyException)
+            {
+                return eLoginEnum.eLoginServerTooBusy;
+            }
+            else if (e is EDBConnectionNotEstablishedException)
+            {
+                return eLoginEnum.eLoginServerTooBusy;
+            }
+
+            return eLoginEnum.eLoginFailedForUnspecifiedError;
         }
 
         /// <summary>
@@ -1641,7 +1100,7 @@
         /// contains the reason why the disconnection cannot take place.</param>
         /// <returns>true if disconnection will take place, otherwise false.
         /// </returns>
-        public Boolean DisconnectClient(System.Int32 AClientID, out String ACantDisconnectReason)
+        public static Boolean DisconnectClient(System.Int32 AClientID, out String ACantDisconnectReason)
         {
             return DisconnectClient(AClientID, "Client closed", out ACantDisconnectReason);
         }
@@ -1656,12 +1115,10 @@
         /// contains the reason why the disconnection cannot take place.</param>
         /// <returns>true if disconnection will take place, otherwise false.
         /// </returns>
-        public Boolean DisconnectClient(System.Int32 AClientID, String AReason, out String ACantDisconnectReason)
+        public static Boolean DisconnectClient(System.Int32 AClientID, String AReason, out String ACantDisconnectReason)
         {
             Boolean ReturnValue;
-            TRunningAppDomain AppDomainEntry;
-            TDisconnectClientThread DisconnectClientThreadObject;
-            Thread DisconnectionThread;
+            TConnectedClient SessionEntry;
 
             ACantDisconnectReason = "";
 
@@ -1670,93 +1127,34 @@
                 TLogging.Log("Trying to disconnect client (ClientID: " + AClientID.ToString() + ") for the reason: " + AReason);
             }
 
-            AppDomainEntry = (TRunningAppDomain)UClientObjects[(object)AClientID];
+            SessionEntry = (TConnectedClient)UClientObjects[(object)AClientID];
+            TLogging.Log("DisconnectClient: SessionEntry.ClientName='" + SessionEntry.ClientName + "'");
+            if (SessionEntry == null)
+            {
+                ACantDisconnectReason = "Can't disconnect ClientID: " + AClientID.ToString() +
+                                        ": Client List entry for this ClientID is empty (should not happen)!";
+                TLogging.Log(ACantDisconnectReason, TLoggingType.ToConsole | TLoggingType.ToLogfile);
+                return false;
+            }
 
-            if (AppDomainEntry == null)
+            if (SessionEntry.FAppDomainStatus == TSessionStatus.adsStopped)
             {
-                // avoid a crash
-                TLogging.Log("Warning: trying to disconnect a non existing client; nothing is done");
+                ACantDisconnectReason = "Can't disconnect ClientID: " + AClientID.ToString() +
+                                        ": this client has been disconnected already!";
+                TLogging.Log(ACantDisconnectReason, TLoggingType.ToConsole | TLoggingType.ToLogfile);
                 return false;
             }
 
             try
             {
-                if (Monitor.TryEnter(AppDomainEntry.DisconnectClientMonitor, 5000))
+                if (Monitor.TryEnter(SessionEntry.DisconnectClientMonitor, 5000))
                 {
                     try
                     {
-                        // Tear down the AppDomain  if an AppDomain for the ClientID exists.
-                        if (!(AppDomainEntry == null))
-                        {
-                            if (AppDomainEntry.ClientAppDomainConnection != null)
-                            {
-                                // Only perform tear down if it is not already in progress!
-                                if (!(AppDomainEntry.ClientDisconnectionScheduled))
-                                {
-                                    AppDomainEntry.ClientDisconnectionScheduled = true;
-                                    DisconnectClientThreadObject = new TDisconnectClientThread();
-                                    DisconnectClientThreadObject.AppDomainEntry = AppDomainEntry;
-                                    DisconnectClientThreadObject.ClientID = AClientID;
-                                    DisconnectClientThreadObject.Reason = AReason;
-
-                                    // Start thread that does the actual disconnection
-                                    DisconnectionThread = new Thread(new ThreadStart(DisconnectClientThreadObject.StartClientDisconnection));
-
-                                    if (TLogging.DL >= 4)
-                                    {
-                                        TLogging.Log(
-                                            "Client disconnection Thread is about to be started for " + "'" + AppDomainEntry.FClientName +
-                                            "' (ClientID: " + AppDomainEntry.FClientID.ToString() + ')' + "...",
-                                            TLoggingType.ToConsole | TLoggingType.ToLogfile);
-                                    }
+                        // Release all memory associated with this session
+                        SessionEntry.EndSession();
 
-                                    DisconnectionThread.Start();
-                                    ReturnValue = true;
-                                }
-                                else
-                                {
-                                    ACantDisconnectReason = "Can't disconnect ClientID " + AClientID.ToString() +
-                                                            ": Client is already disconnecting!";
-                                    TLogging.Log(ACantDisconnectReason, TLoggingType.ToConsole | TLoggingType.ToLogfile);
-                                    ReturnValue = false;
-                                }
-                            }
-                            // AppDomainEntry.ClientAppDomainConnection <> nil
-                            else
-                            {
-                                if ((AppDomainEntry.AppDomainStatus == TAppDomainStatus.adsConnectingLoginVerification)
-                                    || (AppDomainEntry.AppDomainStatus == TAppDomainStatus.adsConnectingLoginOK))
-                                {
-                                    ACantDisconnectReason = "Can't disconnect ClientID " + AClientID.ToString() +
-                                                            ": Client is in the process of connecting!";
-                                }
-                                else
-                                {
-                                    ACantDisconnectReason = "Can't disconnect ClientID " + AClientID.ToString() + ": Client is already disconnected!";
-                                }
-
-                                TLogging.Log(ACantDisconnectReason, TLoggingType.ToConsole | TLoggingType.ToLogfile);
-                                ReturnValue = false;
-                            }
-                        }
-                        // not (AppDomainEntry = nil)
-                        else
-                        {
-                            if (UClientObjects.Contains((object)AClientID))
-                            {
-                                ACantDisconnectReason = "Can't disconnect ClientID: " + AClientID.ToString() +
-                                                        ": Client List entry for this ClientID is empty (should not happen)!";
-                                TLogging.Log(ACantDisconnectReason, TLoggingType.ToConsole | TLoggingType.ToLogfile);
-                                ReturnValue = false;
-                            }
-                            else
-                            {
-                                ACantDisconnectReason = "Can't disconnect ClientID: " + AClientID.ToString() +
-                                                        ": Client List entry for this ClientID doesn't exist (should not happen)!";
-                                TLogging.Log(ACantDisconnectReason, TLoggingType.ToConsole | TLoggingType.ToLogfile);
-                                ReturnValue = false;
-                            }
-                        }
+                        ReturnValue = true;
                     }
                     catch (Exception Exp)
                     {
@@ -1779,7 +1177,7 @@
             }
             finally
             {
-                Monitor.Exit(AppDomainEntry.DisconnectClientMonitor);
+                Monitor.Exit(SessionEntry.DisconnectClientMonitor);
             }
             return ReturnValue;
         }
@@ -1793,7 +1191,7 @@
         /// </summary>
         /// <returns>Result of a call to GC.GetTotalMemory.
         /// </returns>
-        public System.Int32 GCGetApproxMemory()
+        public static System.Int32 GCGetApproxMemory()
         {
             System.Int32 ReturnValue;
             ReturnValue = (int)GC.GetTotalMemory(false);
@@ -1811,7 +1209,7 @@
         /// <param name="AObject">Remoted Object</param>
         /// <returns>GC Generation (or -1 if the object no longer exists)
         /// </returns>
-        public System.Int32 GCGetGCGeneration(object AObject)
+        public static System.Int32 GCGetGCGeneration(object AObject)
         {
             System.Int32 ReturnValue;
             try
@@ -1834,13 +1232,11 @@
         /// </summary>
         /// <returns>Result of a call to GC.GetTotalMemory after the GC was performed.
         /// </returns>
-        public System.Int32 GCPerformGC()
+        public static System.Int32 GCPerformGC()
         {
             GC.Collect();
             Console.WriteLine("TClientManager.PerformGC: GC performed");
             return (int)GC.GetTotalMemory(false);
         }
-
-        #endregion
     }
 }
\ No newline at end of file
